/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <errno.h>

#include <EGL/egl.h>
#include <GLES/gl.h>

#include <android/sensor.h>
#include <android/log.h>

#include "base/Log.h"
#include "sac/base/Vector2.h"
#include "../sources/Game.h"
#include "sac/systems/RenderingSystem.h"
#include "sac/systems/SoundSystem.h"
#include "sac/base/TouchInputManager.h"
#include "../sources/states/ScoreBoardStateManager.h"
#include <png.h>
#include <algorithm>

#include <sys/time.h>
#define DT 1.0/60.

#ifndef _Included_net_damsy_soupeaucaillou_tilematch_TilematchJNILib
#define _Included_net_damsy_soupeaucaillou_tilematch_TilematchJNILib
#ifdef __cplusplus
extern "C" {
#endif

class SaveStateScoreStorage: public ScoreStorage {
	public:

	std::vector<ScoreEntry> loadFromStorage() {
		std::vector<ScoreEntry> result;
		std::sort(result.begin(), result.end(), ScoreStorage::ScoreEntryComp);
		return result;
	}

	void saveToStorage(const std::vector<ScoreEntry>& entries) {

	}
};


struct GameHolder {
	Game* game;
	JavaSoundAPI* api;
	int width, height;
	SaveStateScoreStorage storage;

	struct __input {
		 int touching;
		 float x, y;
	} input;
	bool firstCall;
	struct timeval startup_time;
	float dtAccumuled, time;

	JNIEnv *env;
	jobject assetManager;
	int openGLESVersion;
};

struct AndroidNativeTouchState : public NativeTouchState{
	GameHolder* holder;
	AndroidNativeTouchState(GameHolder* h) : holder(h) {}

	bool isTouching (Vector2* windowCoords) const {
		windowCoords->X = holder->input.x;
		windowCoords->Y = holder->input.y;

		return holder->input.touching;
	}
};

struct AndroidNativeAssetLoader: public NativeAssetLoader {
	GameHolder* holder;
	AndroidNativeAssetLoader(GameHolder* h) : holder(h) {}

	char* decompressPngImage(const std::string& assetName, int* width, int* height);

	char* loadShaderFile(const std::string& assetName);
};


static char* loadTextfile(const char* assetName);
static char* loadPng(const char* assetName, int* width, int* height);

#define UPDATE_ENV_PTR(hld, env) if (hld->env != env) hld->env = hld->api->env = env

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    createGame
 * Signature: ()J
 */
JNIEXPORT jlong JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_createGame
  (JNIEnv *env, jclass, jobject asset, jint openglesVersion) {
  	LOGW("%s -->", __FUNCTION__);
  	TimeUtil::init();
	GameHolder* hld = new GameHolder();
	hld->game = new Game(&hld->storage);
	hld->env = env;
	hld->openGLESVersion = openglesVersion;
	hld->assetManager = (jobject)env->NewGlobalRef(asset);
	theRenderingSystem.setNativeAssetLoader(new AndroidNativeAssetLoader(hld));
	theRenderingSystem.opengles2 = (hld->openGLESVersion == 2);
	theTouchInputManager.setNativeTouchStatePtr(new AndroidNativeTouchState(hld));
	
	LOGW("Build Java sound API proxy env:%p", env);
	hld->api = new JavaSoundAPI();
	hld->api->env = env;
	hld->api->javaSoundApi = (jclass)env->NewGlobalRef(hld->env->FindClass("net/damsy/soupeaucaillou/tilematch/TilematchJNILib"));
	hld->api->jloadSound = (hld->env->GetStaticMethodID(hld->api->javaSoundApi, "loadSound", "(Landroid/content/res/AssetManager;Ljava/lang/String;Z)I"));
	hld->api->jplaySound = (hld->env->GetStaticMethodID(hld->api->javaSoundApi, "playSound", "(IZ)I"));
	hld->api->jpauseSounds = (hld->env->GetStaticMethodID(hld->api->javaSoundApi, "pauseAllSounds", "()V"));
	hld->api->jresumeSounds = (hld->env->GetStaticMethodID(hld->api->javaSoundApi, "resumeAllSounds", "()V"));	
	hld->api->jmusicPos = (hld->env->GetStaticMethodID(hld->api->javaSoundApi, "musicPosition", "(I)F"));
	hld->api->assetManager = hld->assetManager;
	theSoundSystem.androidSoundAPI = hld->api;
	
	LOGW("%s <--", __FUNCTION__);
	return (jlong)hld;
}

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    init
 * Signature: (JII)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_init
  (JNIEnv *env, jclass, jlong g, jint w, jint h, jbyteArray jstate) {
  LOGW("%s -->", __FUNCTION__);
	GameHolder* hld = (GameHolder*) g;
	UPDATE_ENV_PTR(hld, env);
	hld->width = w;
	hld->height = h;

	uint8_t* state = 0;
	int size = 0;
	if (jstate) {
		size = env->GetArrayLength(jstate);
		state = (uint8_t*)env->GetByteArrayElements(jstate, NULL);
		LOGW("Restoring saved state (size:%d)", size);
	} else {
		LOGW("No saved state: creating a new Game instance from scratch");
	}

	hld->game->init(hld->width, hld->height, state, size);
	theTouchInputManager.init(Vector2(10, 10. * hld->height / hld->width), Vector2(hld->width, hld->height));

	hld->firstCall = true;
	hld->dtAccumuled = 0;
	LOGW("%s <--", __FUNCTION__);
}

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    step
 * Signature: (J)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_step
  (JNIEnv *env, jclass, jlong g) {
  	GameHolder* hld = (GameHolder*) g;
  	UPDATE_ENV_PTR(hld, env);
	if (!hld->game)
  		return;
  		
  	if (hld->firstCall) {
		hld->time = TimeUtil::getTime();
		hld->firstCall = false;
	}

	float dt;
	do {
		dt = TimeUtil::getTime() - hld->time;
		if (dt < DT) {
			struct timespec ts;
			ts.tv_sec = 0;
			ts.tv_nsec = (DT - dt) * 1000000000LL;
			nanosleep(&ts, 0);
		}
	} while (dt < DT);

	hld->dtAccumuled += dt;
	hld->time = TimeUtil::getTime();

	while (hld->dtAccumuled >= DT){
		hld->game->tick(hld->dtAccumuled, true);
		hld->dtAccumuled = 0;
		// hld->dtAccumuled -= DT;
	}
}

JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_pause
  (JNIEnv *env, jclass, jlong g) {
  	GameHolder* hld = (GameHolder*) g;
  	LOGW("%s -->", __FUNCTION__);
  	if (!hld->game)
  		return;

	hld->game->togglePause(true);
	LOGW("%s <--", __FUNCTION__);
}

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    handleInputEvent
 * Signature: (JIFF)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_handleInputEvent
  (JNIEnv *env, jclass, jlong g, jint evt, jfloat x, jfloat y) {
	GameHolder* hld = (GameHolder*) g;

	/* ACTION_DOWN == 0 | ACTION_MOVE == 2 */
   if (evt == 0 || evt == 2) {
   	hld->input.touching = 1;
    	hld->input.x = x;
   	hld->input.y = y;
   }
   /* ACTION_UP == 1 */
   else if (evt == 1) {
    	hld->input.touching = 0;
   }
}

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    serialiazeState
 * Signature: (J)[B
 */
JNIEXPORT jbyteArray JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_serialiazeState
  (JNIEnv *env, jclass, jlong g) {
	LOGW("%s -->", __FUNCTION__);
	GameHolder* hld = (GameHolder*) g;
	uint8_t* state;
	int size = hld->game->saveState(&state);

	jbyteArray jb = 0;
	if (size) {
		jb = env->NewByteArray(size);
		env->SetByteArrayRegion(jb, 0, size, (jbyte*)state);
		LOGW("Serialized state size: %d", size);
	}

	LOGW("%s <--", __FUNCTION__);
	return jb;
}

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    restoreRenderingSystemState
 * Signature: (J[B)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_initAndReloadTextures
  (JNIEnv *env, jclass, jlong g) {
  LOGW("%s -->", __FUNCTION__);
  GameHolder* hld = (GameHolder*) g;
  UPDATE_ENV_PTR(hld, env);
  theRenderingSystem.init();
  theRenderingSystem.reloadTextures();
  LOGW("%s <--", __FUNCTION__);
}

static char* loadAsset(GameHolder* hld, const std::string& assetName, int* length) {
	jclass util = hld->env->FindClass("net/damsy/soupeaucaillou/tilematch/TilematchJNILib");
	if (!util) {
		LOGW("ERROR - cannot find class (%p)", hld->env);
	}
	jmethodID mid = hld->env->GetStaticMethodID(util, "assetToByteArray", "(Landroid/content/res/AssetManager;Ljava/lang/String;)[B");

	jstring asset = (hld->env)->NewStringUTF(assetName.c_str());

	jobject _a = hld->env->CallStaticObjectMethod(util, mid, hld->assetManager, asset);

	if (_a) {
		jbyteArray a = (jbyteArray)_a;
		*length = (hld->env)->GetArrayLength(a);
		jbyte* res = new jbyte[*length + 1];
		(hld->env)->GetByteArrayRegion(a, 0, *length, res);
		res[*length] = '\0';
		return (char*)res;
	} else {
		LOGW("%s failed to load '%s'\n", __FUNCTION__, assetName.c_str());
		return 0;
	}
}

void read_from_buffer(png_structp png_ptr, png_bytep outBytes,
   png_size_t byteCountToRead) {
   if(png_ptr->io_ptr == NULL)
      return;   // add custom error handling here
   char* buffer = (char*)png_ptr->io_ptr;
   memcpy(outBytes, buffer, byteCountToRead);

	png_ptr->io_ptr = buffer + byteCountToRead;
}

char* AndroidNativeAssetLoader::decompressPngImage(const std::string& assetName, int* width, int* height)
{
	LOGI("loadPng: %s\n", assetName.c_str());
	png_byte* PNG_image_buffer;
	int length = 0;
	char* data = loadAsset(holder, assetName, &length);

	GLubyte PNG_header[8];

	memcpy(PNG_header, data, 8);
	if (png_sig_cmp(PNG_header, 0, 8) != 0) {
		LOGW("%s is not a PNG\n", assetName.c_str());
		return 0;
	}

	png_structp PNG_reader = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
	if (PNG_reader == NULL)
	{
		LOGW("Can't start reading %s.\n", assetName.c_str());
		delete[] data;
		return 0;
	}

	png_infop PNG_info = png_create_info_struct(PNG_reader);
	if (PNG_info == NULL)
	{
		LOGW("ERROR: Can't get info for %s\n", assetName.c_str());
		png_destroy_read_struct(&PNG_reader, NULL, NULL);
		delete[] data;
		return 0;
	}

	png_infop PNG_end_info = png_create_info_struct(PNG_reader);
	if (PNG_end_info == NULL)
	{
		LOGW("ERROR: Can't get end info for %s\n", assetName.c_str());
		png_destroy_read_struct(&PNG_reader, &PNG_info, NULL);
		delete[] data;
		return 0;
	}

	if (setjmp(png_jmpbuf(PNG_reader)))
	{
		LOGW("ERROR: Can't load %s\n", assetName.c_str());
		png_destroy_read_struct(&PNG_reader, &PNG_info, &PNG_end_info);
		delete[] data;
		return 0;
	}

	png_set_read_fn(PNG_reader, &data[8], read_from_buffer);
	// png_init_io(PNG_reader, PNG_file);
	png_set_sig_bytes(PNG_reader, 8);

	png_read_info(PNG_reader, PNG_info);

	*width = png_get_image_width(PNG_reader, PNG_info);
	*height = png_get_image_height(PNG_reader, PNG_info);

	png_uint_32 bit_depth, color_type;
	bit_depth = png_get_bit_depth(PNG_reader, PNG_info);
	color_type = png_get_color_type(PNG_reader, PNG_info);

	if (color_type == PNG_COLOR_TYPE_PALETTE)
	{
		png_set_palette_to_rgb(PNG_reader);
	}

	if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
	{
		png_set_expand_gray_1_2_4_to_8(PNG_reader);
	}

	if (color_type == PNG_COLOR_TYPE_GRAY ||
		color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
	{
		png_set_gray_to_rgb(PNG_reader);
	}

	if (png_get_valid(PNG_reader, PNG_info, PNG_INFO_tRNS))
	{
		png_set_tRNS_to_alpha(PNG_reader);
	}
	else
	{
		png_set_filler(PNG_reader, 0xff, PNG_FILLER_AFTER);
	}

	if (bit_depth == 16)
	{
		png_set_strip_16(PNG_reader);
	}

	png_read_update_info(PNG_reader, PNG_info);

	PNG_image_buffer = (png_byte*)malloc(4 * (*width) * (*height));
	png_byte** PNG_rows = (png_byte**)malloc(*height * sizeof(png_byte*));

	unsigned int row;
	for (row = 0; row < *height; ++row) {
		PNG_rows[*height - 1 - row] = PNG_image_buffer + (row * 4 * *width);
	}

	png_read_image(PNG_reader, PNG_rows);

	free(PNG_rows);

	png_destroy_read_struct(&PNG_reader, &PNG_info, &PNG_end_info);
	delete[] data;

	return (char*)PNG_image_buffer;
}

char* AndroidNativeAssetLoader::loadShaderFile(const std::string& assetName)
{
	LOGI("loadTextFile: %s", assetName.c_str());
	int length = 0;
	char* result = loadAsset(holder, assetName, &length);
	return result;
}

#ifdef __cplusplus
}
#endif
#endif

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <errno.h>

#include <EGL/egl.h>
#include <GLES/gl.h>

#include <android/sensor.h>
#include <android/log.h>

#define LOGI(...) ((void)__android_log_print(ANDROID_LOG_INFO, "tilematch", __VA_ARGS__))
#define LOGW(...) ((void)__android_log_print(ANDROID_LOG_WARN, "tilematch", __VA_ARGS__))

#include "sac/base/Vector2.h"
#include "../sources/Game.h"
#include "sac/systems/RenderingSystem.h"
#include "sac/base/TouchInputManager.h"
#include "../sources/states/ScoreBoardStateManager.h"
#include <png.h>
#include <algorithm>

#include <sys/time.h>
#define DT 1.0/60.

#ifndef _Included_net_damsy_soupeaucaillou_tilematch_TilematchJNILib
#define _Included_net_damsy_soupeaucaillou_tilematch_TilematchJNILib
#ifdef __cplusplus
extern "C" {
#endif

class SaveStateScoreStorage: public ScoreStorage {
	public:

	std::vector<ScoreEntry> loadFromStorage() {
		std::vector<ScoreEntry> result;
		std::sort(result.begin(), result.end(), ScoreStorage::ScoreEntryComp);
		return result;
	}

	void saveToStorage(const std::vector<ScoreEntry>& entries) {

	}
};


struct GameHolder {
	Game* game;
	int width, height;
	SaveStateScoreStorage storage;

	struct __input {
		 int touching;
		 float x, y;
	} input;
	struct timeval startup_time;
	float dtAccumuled, time;

	JNIEnv *env;
	jobject assetManager;
};

struct AndroidNativeTouchState : public NativeTouchState{
	GameHolder* holder;
	AndroidNativeTouchState(GameHolder* h) : holder(h) {}

	bool isTouching (Vector2* windowCoords) const {
		windowCoords->X = holder->input.x;
		windowCoords->Y = holder->input.y;

		return holder->input.touching;
	}
};

struct AndroidNativeAssetLoader: public NativeAssetLoader {
	GameHolder* holder;
	AndroidNativeAssetLoader(GameHolder* h) : holder(h) {}

	char* decompressPngImage(const std::string& assetName, int* width, int* height);

	char* loadShaderFile(const std::string& assetName);
};


static char* loadTextfile(const char* assetName);
static char* loadPng(const char* assetName, int* width, int* height);

static float timeconverter(struct timeval tv) {
	return (tv.tv_sec + tv.tv_usec / 1000000.0f);
}

static float gettime(GameHolder* hld) {
	struct timeval tv;
	gettimeofday(&tv,NULL);
	timersub(&tv, &hld->startup_time, &tv);
	return timeconverter(tv);
}

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    createGame
 * Signature: ()J
 */
JNIEXPORT jlong JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_createGame
  (JNIEnv *env, jclass, jobject asset) {
	GameHolder* hld = new GameHolder();
	hld->game = new Game();
	hld->env = env;
	hld->assetManager = (jobject)env->NewGlobalRef(asset);

	return (jlong)hld;
}

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    init
 * Signature: (JII)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_init
  (JNIEnv *env, jclass, jlong g, jint w, jint h) {
	GameHolder* hld = (GameHolder*) g;
	hld->width = w;
	hld->height = h;

	theRenderingSystem.setNativeAssetLoader(new AndroidNativeAssetLoader(hld));
	theTouchInputManager.setNativeTouchStatePtr(new AndroidNativeTouchState(hld));
	hld->game->init(&hld->storage, hld->width, hld->height);
	theRenderingSystem.init();
   theTouchInputManager.init(Vector2(10, 10. * hld->height / hld->width), Vector2(hld->width, hld->height));

	gettimeofday(&hld->startup_time,NULL);
	hld->time = gettime(hld);
	hld->dtAccumuled = 0;
}

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    step
 * Signature: (J)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_step
  (JNIEnv *, jclass, jlong g) {
  	GameHolder* hld = (GameHolder*) g;

	float dt;
	do {
		dt = gettime(hld) - hld->time;
		if (dt < DT) {
			struct timespec ts;
			ts.tv_sec = 0;
			ts.tv_nsec = (DT - dt) * 1000000000LL;
			nanosleep(&ts, 0);
		}
	} while (dt < DT);

	hld->dtAccumuled += dt;
	hld->time = gettime(hld);

	while (hld->dtAccumuled >= DT){
		hld->game->tick(hld->dtAccumuled);
		hld->dtAccumuled = 0;
		// hld->dtAccumuled -= DT;
	}
}

/*
 * Class:     net_damsy_soupeaucaillou_tilematch_TilematchJNILib
 * Method:    handleInputEvent
 * Signature: (JIFF)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_tilematch_TilematchJNILib_handleInputEvent
  (JNIEnv *, jclass, jlong g, jint evt, jfloat x, jfloat y) {
	GameHolder* hld = (GameHolder*) g;

	/* ACTION_DOWN == 0 | ACTION_MOVE == 2 */
   if (evt == 0 || evt == 2) {
   	hld->input.touching = 1;
    	hld->input.x = x;
   	hld->input.y = y;
   }
   /* ACTION_UP == 1 */
   else if (evt == 1) {
    	hld->input.touching = 0;
   }
}

static char* loadAsset(GameHolder* hld, const std::string& assetName, int* length) {
	jclass util = hld->env->FindClass("net/damsy/soupeaucaillou/tilematch/TilematchJNILib");
	jmethodID mid = hld->env->GetStaticMethodID(util, "assetToByteArray", "(Landroid/content/res/AssetManager;Ljava/lang/String;)[B");

	jstring asset = (hld->env)->NewStringUTF(assetName.c_str());

	jobject _a = hld->env->CallStaticObjectMethod(util, mid, hld->assetManager, asset);

	if (_a) {
		jbyteArray a = (jbyteArray)_a;
		*length = (hld->env)->GetArrayLength(a);
		LOGI("%s size:%d\n", __FUNCTION__, *length);
		jbyte* res = new jbyte[*length + 1];
		(hld->env)->GetByteArrayRegion(a, 0, *length, res);
		res[*length] = '\0';
		return (char*)res;
	} else {
		LOGW("%s failed to load '%s'\n", __FUNCTION__, assetName.c_str());
		return 0;
	}
}

void read_from_buffer(png_structp png_ptr, png_bytep outBytes,
   png_size_t byteCountToRead) {
   if(png_ptr->io_ptr == NULL)
      return;   // add custom error handling here
   char* buffer = (char*)png_ptr->io_ptr;
   memcpy(outBytes, buffer, byteCountToRead);

	png_ptr->io_ptr = buffer + byteCountToRead;
}

char* AndroidNativeAssetLoader::decompressPngImage(const std::string& assetName, int* width, int* height)
{
	LOGI("loadPng: %s\n", assetName.c_str());
	png_byte* PNG_image_buffer;
	int length = 0;
	char* data = loadAsset(holder, assetName, &length);

	GLubyte PNG_header[8];

	memcpy(PNG_header, data, 8);
	if (png_sig_cmp(PNG_header, 0, 8) != 0) {
		LOGW("%s is not a PNG\n", assetName.c_str());
		return 0;
	}

	png_structp PNG_reader = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
	if (PNG_reader == NULL)
	{
		LOGW("Can't start reading %s.\n", assetName.c_str());
		delete[] data;
		return 0;
	}

	png_infop PNG_info = png_create_info_struct(PNG_reader);
	if (PNG_info == NULL)
	{
		LOGW("ERROR: Can't get info for %s\n", assetName.c_str());
		png_destroy_read_struct(&PNG_reader, NULL, NULL);
		delete[] data;
		return 0;
	}

	png_infop PNG_end_info = png_create_info_struct(PNG_reader);
	if (PNG_end_info == NULL)
	{
		LOGW("ERROR: Can't get end info for %s\n", assetName.c_str());
		png_destroy_read_struct(&PNG_reader, &PNG_info, NULL);
		delete[] data;
		return 0;
	}

	if (setjmp(png_jmpbuf(PNG_reader)))
	{
		LOGW("ERROR: Can't load %s\n", assetName.c_str());
		png_destroy_read_struct(&PNG_reader, &PNG_info, &PNG_end_info);
		delete[] data;
		return 0;
	}

	png_set_read_fn(PNG_reader, &data[8], read_from_buffer);
	// png_init_io(PNG_reader, PNG_file);
	png_set_sig_bytes(PNG_reader, 8);

	png_read_info(PNG_reader, PNG_info);

	*width = png_get_image_width(PNG_reader, PNG_info);
	*height = png_get_image_height(PNG_reader, PNG_info);

	png_uint_32 bit_depth, color_type;
	bit_depth = png_get_bit_depth(PNG_reader, PNG_info);
	color_type = png_get_color_type(PNG_reader, PNG_info);

	if (color_type == PNG_COLOR_TYPE_PALETTE)
	{
		png_set_palette_to_rgb(PNG_reader);
	}

	if (color_type == PNG_COLOR_TYPE_GRAY && bit_depth < 8)
	{
		png_set_expand_gray_1_2_4_to_8(PNG_reader);
	}

	if (color_type == PNG_COLOR_TYPE_GRAY ||
		color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
	{
		png_set_gray_to_rgb(PNG_reader);
	}

	if (png_get_valid(PNG_reader, PNG_info, PNG_INFO_tRNS))
	{
		png_set_tRNS_to_alpha(PNG_reader);
	}
	else
	{
		png_set_filler(PNG_reader, 0xff, PNG_FILLER_AFTER);
	}

	if (bit_depth == 16)
	{
		png_set_strip_16(PNG_reader);
	}

	png_read_update_info(PNG_reader, PNG_info);

	PNG_image_buffer = (png_byte*)malloc(4 * (*width) * (*height));
	png_byte** PNG_rows = (png_byte**)malloc(*height * sizeof(png_byte*));

	unsigned int row;
	for (row = 0; row < *height; ++row) {
		PNG_rows[*height - 1 - row] = PNG_image_buffer + (row * 4 * *width);
	}

	png_read_image(PNG_reader, PNG_rows);

	free(PNG_rows);

	png_destroy_read_struct(&PNG_reader, &PNG_info, &PNG_end_info);
	delete[] data;

	return (char*)PNG_image_buffer;
}

char* AndroidNativeAssetLoader::loadShaderFile(const std::string& assetName)
{
	LOGI("loadTextFile: %s", assetName.c_str());
	int length = 0;
	char* result = loadAsset(holder, assetName, &length);
	return result;
}

#ifdef __cplusplus
}
#endif
#endif

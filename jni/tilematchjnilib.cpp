/*
	This file is part of Heriswap.

	@author Soupe au Caillou - Pierre-Eric Pelloux-Prayer
	@author Soupe au Caillou - Gautier Pelloux-Prayer

	Heriswap is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, version 3.

	Heriswap is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Heriswap.  If not, see <http://www.gnu.org/licenses/>.
*/
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <errno.h>

#include <EGL/egl.h>
#include <GLES/gl.h>

#include <android/sensor.h>
#include <android/log.h>

#include "base/Log.h"
#include "sac/base/Vector2.h"
#include "../sources/Game.h"
#include "sac/systems/RenderingSystem.h"
#include "sac/systems/SoundSystem.h"
#include "sac/systems/MusicSystem.h"
#include "sac/base/TouchInputManager.h"
#include "sac/base/EntityManager.h"

#include "sac/api/android/AssetAPIAndroidImpl.h"
#include "sac/api/android/MusicAPIAndroidImpl.h"
#include "sac/api/android/SoundAPIAndroidImpl.h"
#include "sac/api/android/LocalizeAPIAndroidImpl.h"
#include "sac/api/android/NameInputAPIAndroidImpl.h"
#include "sac/api/android/AdAPIAndroidImpl.h"
#include "sac/api/android/ExitAPIAndroidImpl.h"

#include "api/android/StorageAPIAndroidImpl.h"

#include <png.h>
#include <algorithm>

#include <sys/time.h>
#define DT 1.0/60.

#ifndef _Included_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib
#define _Included_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib
#ifdef __cplusplus
extern "C" {
#endif

struct GameHolder;

class AndroidSuccessAPI : public SuccessAPI {
	public:
		GameHolder* holder;
		void successCompleted(const char* description, unsigned long successId);
        void openfeintLB(int mode, int diff);
        void openfeintSuccess();
};

enum {
	FROM_GAME_THREAD = 0,
	FROM_RENDER_THREAD,
	THREAD_COUNT
};

struct JNIEnvDependantContext {
	virtual void init(JNIEnv* pEnv, jobject assetMgr) { env = pEnv; }	
	virtual void uninit(JNIEnv* pEnv) { env = 0; }
	
	JNIEnv* env;
};

struct GameThreadJNIEnvCtx : JNIEnvDependantContext {
	NameInputAPIAndroidImpl nameInput;
    StorageAPIAndroidImpl storage;
	LocalizeAPIAndroidImpl localize;
    AdAPIAndroidImpl ad;
    AssetAPIAndroidImpl asset;
	ExitAPIAndroidImpl exitAPI;
	MusicAPIAndroidImpl musicAPI;
	SoundAPIAndroidImpl soundAPI;
	jobject assetManager;
	
	void init(JNIEnv* env, jobject assetMgr) {
		assetManager = env->NewGlobalRef(assetMgr);

		nameInput.init(env);
	    storage.init(env);
		localize.init(env);
	    ad.init(env);
	    asset.init(env, assetManager);
		exitAPI.init(env);
		musicAPI.init(env);
		soundAPI.init(env, assetManager);
	
		JNIEnvDependantContext::init(env, assetMgr);
	}
	
	void uninit(JNIEnv* pEnv) {
		if (env == pEnv) {
			nameInput.uninit();
		    storage.uninit();
			localize.uninit();
		    ad.uninit();
		    asset.uninit();
			exitAPI.uninit();
			musicAPI.uninit();
			soundAPI.uninit();
			env->DeleteGlobalRef(assetManager);
		}
		
		JNIEnvDependantContext::uninit(pEnv);
	}
};

struct RenderThreadJNIEnvCtx : JNIEnvDependantContext {
    AssetAPIAndroidImpl asset;
	jobject assetManager;
	
	void init(JNIEnv* env, jobject assetMgr) {
		assetManager = env->NewGlobalRef(assetMgr);
	    asset.init(env, assetManager);
		JNIEnvDependantContext::init(env, assetMgr);
	}
	
	void uninit(JNIEnv* pEnv) {
		if (env == pEnv) {
			asset.uninit();
			env->DeleteGlobalRef(assetManager);
		}
		JNIEnvDependantContext::uninit(pEnv);
	}
};

struct GameHolder {
	Game* game;
	int width, height;
	
	GameThreadJNIEnvCtx gameThreadJNICtx;
	RenderThreadJNIEnvCtx renderThreadJNICtx;
	AndroidSuccessAPI success;
	
	struct __input {
		 int touching;
		 float x, y;
	} input;
	bool firstCall;
	struct timeval startup_time;
	float dtAccumuled, time;

	int openGLESVersion;
	bool initDone;
};

struct AndroidNativeTouchState : public NativeTouchState{
	GameHolder* holder;
	AndroidNativeTouchState(GameHolder* h) : holder(h) {}

	bool isTouching (Vector2* windowCoords) const {
		windowCoords->X = holder->input.x;
		windowCoords->Y = holder->input.y;

		return holder->input.touching;
	}
};

static char* loadTextfile(const char* assetName);
static char* loadPng(const char* assetName, int* width, int* height);

/*
 * Class:     net_damsy_soupeaucaillou_heriswap_HeriswapJNILib
 * Method:    createGame
 * Signature: ()J
 */
JNIEXPORT jlong JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_createGame
  (JNIEnv *env, jclass, jint openglesVersion) {
  	LOGW("%s -->", __FUNCTION__);
  	TimeUtil::init();
	GameHolder* hld = new GameHolder();
	hld->initDone = false;
	hld->game = new Game(&hld->renderThreadJNICtx.asset, 
		&hld->gameThreadJNICtx.storage,
		&hld->gameThreadJNICtx.nameInput,
		&hld->success,
		&hld->gameThreadJNICtx.localize,
		&hld->gameThreadJNICtx.ad,
		&hld->gameThreadJNICtx.exitAPI);
	
	hld->openGLESVersion = openglesVersion;
	theRenderingSystem.assetAPI = &hld->renderThreadJNICtx.asset;
	theRenderingSystem.opengles2 = (hld->openGLESVersion == 2);
	theTouchInputManager.setNativeTouchStatePtr(new AndroidNativeTouchState(hld));
	hld->success.holder = hld;
	return (jlong)hld;
}

JNIEXPORT jlong JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_destroyGame
  (JNIEnv *env, jclass, jlong g) {
    GameHolder* hld = (GameHolder*) g;
    theMusicSystem.uninit();
    delete hld->game;
    delete hld;
}

/*
 * Class:     net_damsy_soupeaucaillou_heriswap_HeriswapJNILib
 * Method:    init
 * Signature: (JII)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_initFromRenderThread
  (JNIEnv *env, jclass, jobject asset, jlong g, jint w, jint h) {
  LOGW("%s -->", __FUNCTION__);
	GameHolder* hld = (GameHolder*) g;
	hld->width = w;
	hld->height = h;
	
	hld->renderThreadJNICtx.init(env, asset);

	hld->game->sacInit(hld->width, hld->height);
	LOGW("%s <--", __FUNCTION__);
}

JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_uninitFromRenderThread
  (JNIEnv *env, jclass, jlong g) {
  LOGW("%s -->", __FUNCTION__);
	GameHolder* hld = (GameHolder*) g;
	hld->renderThreadJNICtx.uninit(env);
	LOGW("%s <--", __FUNCTION__);
}

JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_initFromGameThread
  (JNIEnv *env, jclass, jobject asset, jlong g, jbyteArray jstate) {
  	GameHolder* hld = (GameHolder*) g;	
  	bool fullInit = true;
  	
  	if (hld->gameThreadJNICtx.env && hld->gameThreadJNICtx.env != env && !jstate) 
  		fullInit = false;
	hld->gameThreadJNICtx.init(env, asset);
	
	theMusicSystem.musicAPI = &hld->gameThreadJNICtx.musicAPI;
	theMusicSystem.assetAPI = &hld->gameThreadJNICtx.asset;
	theSoundSystem.soundAPI = &hld->gameThreadJNICtx.soundAPI;
	
	theSoundSystem.init();
	
	uint8_t* state = 0;
	int size = 0;
	if (jstate) {
		size = env->GetArrayLength(jstate);
		state = (uint8_t*)env->GetByteArrayElements(jstate, NULL);
		LOGW("Restoring saved state (size:%d)", size);
	} else if (hld->initDone) {
		return;
	} else {
		LOGW("No saved state: creating a new Game instance from scratch");
	}
	
	theMusicSystem.init();
	
	hld->firstCall = true;
	hld->dtAccumuled = 0;

	hld->game->init(state, size);
	hld->initDone = true;
}

JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_uninitFromGameThread
  (JNIEnv *env, jclass, jlong g) {
  LOGW("%s -->", __FUNCTION__);
	GameHolder* hld = (GameHolder*) g;
	hld->gameThreadJNICtx.uninit(env);
	LOGW("%s <--", __FUNCTION__);
}

/*
 * Class:     net_damsy_soupeaucaillou_heriswap_HeriswapJNILib
 * Method:    step
 * Signature: (J)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_step
  (JNIEnv *env, jclass, jlong g) {
  	GameHolder* hld = (GameHolder*) g;

	if (!hld->game)
  		return;

  	if (hld->firstCall) {
		hld->time = TimeUtil::getTime();
		hld->firstCall = false;
	}

	float dt;
	do {
		dt = TimeUtil::getTime() - hld->time;
		if (dt < DT) {
			struct timespec ts;
			ts.tv_sec = 0;
			ts.tv_nsec = (DT - dt) * 1000000000LL;
			nanosleep(&ts, 0);
		}
	} while (dt < DT);

	hld->dtAccumuled += dt;
	hld->time = TimeUtil::getTime();

	const float accum = DT;
	if (hld->dtAccumuled > 5 * DT) {
		LOGW("BIG DT: %.3f s", hld->dtAccumuled);
	}

	while (hld->dtAccumuled >= DT){
		hld->game->tick(accum);
		hld->dtAccumuled -= accum;
	}
}

float pauseTime;
// HACK: this one is called only from Activity::onResume
// Here we'll compute the time since pause. If < 5s -> autoresume the music
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_resetTimestep
  (JNIEnv *env, jclass, jlong g) {
  	GameHolder* hld = (GameHolder*) g;

	if (!hld)
  		return;
  	hld->firstCall = true;
  	float d = TimeUtil::getTime();
  	LOGW("resume time: %.3f, diff:%.3f, %d", d, d - pauseTime, theSoundSystem.mute);
  	if (d - pauseTime <= 5) {
	  	theMusicSystem.toggleMute(theSoundSystem.mute);
  	}
}

static int frameCount = 0;
static float tttttt = 0;

JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_render
  (JNIEnv *env, jclass, jlong g) {
  	GameHolder* hld = (GameHolder*) g;
	theRenderingSystem.render();

	frameCount++;
	if (frameCount >= 200) {
		LOGW("fps render: %.2f", 200.0 / (TimeUtil::getTime() - tttttt));
		tttttt = TimeUtil::getTime();
		frameCount = 0;
	}
}

JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_pause
  (JNIEnv *env, jclass, jlong g) {
  	GameHolder* hld = (GameHolder*) g;
  	LOGW("%s -->", __FUNCTION__);
  	if (!hld->game)
  		return;

    // kill all music
    theMusicSystem.toggleMute(true);
	hld->game->togglePause(true);
	pauseTime = TimeUtil::getTime();
	LOGW("%s <-- %.3f", __FUNCTION__, pauseTime);
}

JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_back
  (JNIEnv *env, jclass, jlong g) {
     GameHolder* hld = (GameHolder*) g;
     LOGW("%s -->", __FUNCTION__);
     if (!hld->game)
         return;

    hld->game->backPressed();
    LOGW("%s <--", __FUNCTION__);
}


JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_invalidateTextures
  (JNIEnv *env, jclass, jobject asset, jlong g) {
     GameHolder* hld = (GameHolder*) g;
     LOGW("%s -->", __FUNCTION__);
     if (!hld->game || !RenderingSystem::GetInstancePointer())
         return;
         
    hld->renderThreadJNICtx.init(env, asset);

    // kill all music
    theRenderingSystem.invalidateAtlasTextures();
    LOGW("%s <--", __FUNCTION__);
}

/*
 * Class:     net_damsy_soupeaucaillou_heriswap_HeriswapJNILib
 * Method:    handleInputEvent
 * Signature: (JIFF)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_handleInputEvent
  (JNIEnv *env, jclass, jlong g, jint evt, jfloat x, jfloat y) {
	GameHolder* hld = (GameHolder*) g;
	
	if (g == 0)
		return;

	/* ACTION_DOWN == 0 | ACTION_MOVE == 2 */
   if (evt == 0 || evt == 2) {
   	hld->input.touching = 1;
    	hld->input.x = x;
   	hld->input.y = y;
   }
   /* ACTION_UP == 1 */
   else if (evt == 1) {
    	hld->input.touching = 0;
   }
}

/*
 * Class:     net_damsy_soupeaucaillou_heriswap_HeriswapJNILib
 * Method:    serialiazeState
 * Signature: (J)[B
 */
JNIEXPORT jbyteArray JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_serialiazeState
  (JNIEnv *env, jclass, jlong g) {
	LOGW("%s -->", __FUNCTION__);
	GameHolder* hld = (GameHolder*) g;
	uint8_t* state;
	int size = hld->game->saveState(&state);

	jbyteArray jb = 0;
	if (size) {
		jb = env->NewByteArray(size);
		env->SetByteArrayRegion(jb, 0, size, (jbyte*)state);
		LOGW("Serialized state size: %d", size);
	}

    // delete hld->game;
    // delete hld;

	LOGW("%s <--", __FUNCTION__);
	return jb;
}

/*
 * Class:     net_damsy_soupeaucaillou_heriswap_HeriswapJNILib
 * Method:    restoreRenderingSystemState
 * Signature: (J[B)V
 */
JNIEXPORT void JNICALL Java_net_damsy_soupeaucaillou_heriswap_HeriswapJNILib_initAndReloadTextures
  (JNIEnv *env, jclass, jlong g) {
  LOGW("%s -->", __FUNCTION__);
  GameHolder* hld = (GameHolder*) g;
  theRenderingSystem.init();
  theRenderingSystem.reloadTextures();
  LOGW("%s <--", __FUNCTION__);
}

static char* loadAsset(JNIEnv *env, jobject assetManager, const std::string& assetName, int* length) {
	jclass util = env->FindClass("net/damsy/soupeaucaillou/heriswap/HeriswapJNILib");
	if (!util) {
		LOGW("ERROR - cannot find class (%p)", env);
	}
	jmethodID mid = env->GetStaticMethodID(util, "assetToByteArray", "(Landroid/content/res/AssetManager;Ljava/lang/String;)[B");
    jstring asset = env->NewStringUTF(assetName.c_str());
    jobject _a = env->CallStaticObjectMethod(util, mid, assetManager, asset);

	if (_a) {
		jbyteArray a = (jbyteArray)_a;
		*length = env->GetArrayLength(a);
		jbyte* res = new jbyte[*length + 1];
		env->GetByteArrayRegion(a, 0, *length, res);
		res[*length] = '\0';
		return (char*)res;
	} else {
		LOGW("%s failed to load '%s'\n", __FUNCTION__, assetName.c_str());
		return 0;
	}
}

void read_from_buffer(png_structp png_ptr, png_bytep outBytes,
   png_size_t byteCountToRead) {
   if(png_ptr->io_ptr == NULL)
      return;   // add custom error handling here
   char* buffer = (char*)png_ptr->io_ptr;
   memcpy(outBytes, buffer, byteCountToRead);

	png_ptr->io_ptr = buffer + byteCountToRead;
}

void AndroidSuccessAPI::successCompleted(const char* description, unsigned long successId) {
	SuccessAPI::successCompleted(description, successId);
	// android spec stuff
	JNIEnv* env = holder->gameThreadJNICtx.env;
	jclass c = env->FindClass("net/damsy/soupeaucaillou/heriswap/HeriswapJNILib");
	jmethodID mid = (env->GetStaticMethodID(c, "unlockAchievement", "(I)V"));
	int sid = (int) successId;
	env->CallStaticVoidMethod(c, mid, sid);
}

void AndroidSuccessAPI::openfeintLB(int mode, int diff) {
	JNIEnv* env = holder->gameThreadJNICtx.env;
	jclass c = env->FindClass("net/damsy/soupeaucaillou/heriswap/HeriswapJNILib");
	jmethodID mid = env->GetStaticMethodID(c, "openfeintLeaderboard", "(II)V");
	env->CallStaticVoidMethod(c, mid, mode, diff);
}

void AndroidSuccessAPI::openfeintSuccess() {
	JNIEnv* env = holder->gameThreadJNICtx.env;
	jclass c = env->FindClass("net/damsy/soupeaucaillou/heriswap/HeriswapJNILib");
	jmethodID mid = env->GetStaticMethodID(c, "openfeintSuccess", "()V");
	env->CallStaticVoidMethod(c, mid);
}
#ifdef __cplusplus
}
#endif
#endif
